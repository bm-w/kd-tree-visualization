// Generated by CoffeeScript 1.4.0

(function() {
  var k, kdTree;
  d3.json('data.json', function(data) {
    var activate, axes, dim, ex, ey, field, g, getX, getY, invert, layout, links, mx, my, nodes, partitionEnd, partitionStart, partitions, r, svg, tree, x, _ref, _ref1, _ref2;
    if (!((data != null) && data.length)) {
      return console.log("No data...", data);
    } else {
      console.log("Got data (N = " + data.length + ")!");
      tree = kdTree(data);
      layout = d3.layout.tree();
      dim = [288, 240];
      activate = function(selector, container, b) {
        return function(d) {
          var id, _ref;
          id = ((_ref = d.value) != null ? _ref.id : void 0) || d.id;
          return (d3.selectAll("" + selector + "[data-id=\"" + id + "\"], " + container)).classed('active', b);
        };
      };
      nodes = layout(tree);
      links = ((((((d3.select('g.tree')).append('svg:g')).classed('links', true)).selectAll('line.link')).data(layout.links(nodes))).enter()).append('svg:line');
      links.attr('x1', function(d) {
        return dim[0] * d.source.x;
      });
      links.attr('y1', function(d) {
        return dim[1] * d.source.y;
      });
      links.attr('x2', function(d) {
        return dim[0] * d.target.x;
      });
      links.attr('y2', function(d) {
        return dim[1] * d.target.y;
      });
      svg = d3.select('svg');
      g = (((((((d3.select('g.tree')).selectAll('g.node')).data(nodes)).enter()).append('svg:g')).classed('node', true)).attr('data-id', function(d) {
        return d.value.id;
      })).attr('transform', function(d) {
        return "translate(" + (dim[0] * d.x) + "," + (dim[1] * d.y) + ")";
      });
      (g.append('svg:circle')).attr('r', 12);
      ((g.append('svg:text')).classed('label', true)).text(function(d, i) {
        return d.value.id;
      });
      ((g.append('svg:text')).classed('coords', true)).text(function(d) {
        var i, v, x;
        v = (function() {
          var _results;
          _results = [];
          for (i in (x = d.value.x)) {
            _results.push(x[i].toFixed(2));
          }
          return _results;
        })();
        return "(" + (v.join(',')) + ")";
      });
      g.on('mouseover', activate('.point', '.field', true));
      g.on('mouseout', activate('.point', '.field', false));
      field = d3.select('g.field');
      x = ((d3.scale.linear()).domain([-4, 4])).rangeRound([-480, 480]);
      _ref = [
        (function(d) {
          return d.x[0];
        }), (function(d) {
          return d.x[1];
        })
      ], getX = _ref[0], getY = _ref[1];
      _ref1 = [d3.mean(data, getX), d3.extent(data, getX)], mx = _ref1[0], ex = _ref1[1];
      _ref2 = [d3.mean(data, getY), d3.extent(data, getY)], my = _ref2[0], ey = _ref2[1];
      r = 8;
      axes = (field.append('svg:g')).classed("axes", true);
      (axes.append('svg:circle')).attr('r', x(1));
      ((axes.append('svg:line')).attr('x1', -2 - r + x(ex[0]))).attr('x2', 2 + r + x(ex[1]));
      ((axes.append('svg:line')).attr('y1', -2 - r + x(ey[0]))).attr('y2', 2 + r + x(ey[1]));
      invert = function(k, b) {
        if (k === 0) {
          return b;
        } else {
          return !b;
        }
      };
      partitionStart = function(k, ek) {
        return function(d) {
          var _ref3;
          if (invert(k, d.depth % 2 === 0)) {
            return 0.5 + x(d.value.x[k]);
          } else {
            return x(((_ref3 = d.parent) != null ? _ref3.value.x[k] : void 0) || ek[0]);
          }
        };
      };
      partitionEnd = function(k, ek) {
        return function(d) {
          var e, gp, p, vd, vgp, vp, _ref3, _ref4, _ref5, _ref6;
          if (invert(k, d.depth % 2 === 0)) {
            return 0.5 + x(d.value.x[k]);
          } else {
            _ref4 = [d.value.x[k], ((_ref3 = (p = d.parent)) != null ? _ref3.value.x[k] : void 0) || -Infinity], vd = _ref4[0], vp = _ref4[1];
            _ref5 = [p, [ek[0], ek[1]]], gp = _ref5[0], e = _ref5[1];
            while ((gp = gp != null ? (_ref6 = gp.parent) != null ? _ref6.parent : void 0 : void 0) != null) {
              vgp = gp.value.x[k];
              if (vd > vgp) {
                e[0] = Math.max(vgp, e[0]);
              } else {
                e[1] = Math.min(vgp, e[1]);
              }
            }
            return x(e[vd < vp ? 0 : 1]);
          }
        };
      };
      partitions = (((((field.append('svg:g')).classed('partitions', true)).selectAll('line')).data(nodes)).enter()).append('svg:line');
      partitions.attr('data-id', function(d) {
        return d.value.id;
      });
      partitions.attr('x1', partitionStart(0, ex));
      partitions.attr('y1', partitionStart(1, ey));
      partitions.attr('x2', partitionEnd(0, ex));
      partitions.attr('y2', partitionEnd(1, ey));
      g = ((((((field.selectAll('g.point')).data(data)).enter()).append('svg:g')).classed("point", true)).attr('data-id', function(d) {
        return d.id;
      })).attr('transform', function(d) {
        return "translate(" + (x(d.x[0])) + "," + (x(d.x[1])) + ")";
      });
      (g.append('svg:circle')).attr('r', r);
      ((g.append('svg:text')).classed('label', true)).text(function(d) {
        return d.id;
      });
      g.on('mouseover', activate('.node', '.tree', true));
      return g.on('mouseout', activate('.node', '.tree', false));
    }
  });
  k = 2;
  return kdTree = function(data, depth) {
    var axis, children, medianIndex, node, sortedData, _ref;
    if (depth == null) {
      depth = 0;
    }
    if (!data.length) {
      return;
    }
    _ref = [depth++ % k, Math.floor(data.length / 2)], axis = _ref[0], medianIndex = _ref[1];
    sortedData = data.sort(function(d0, d1) {
      return d3.ascending(d0.x[axis], d1.x[axis]);
    });
    children = [kdTree(sortedData.slice(0, medianIndex), depth), kdTree(sortedData.slice(medianIndex + 1), depth)].filter(function(e) {
      return e;
    });
    return node = {
      value: sortedData[medianIndex],
      children: children.length ? children : null
    };
  };
}).call(this);
